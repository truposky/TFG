\subsection{infraestructura}
Detallado como se ha construido el robot para tener multiples agentes que realicen los algoritmos, ahora se detalla como se ordenan los movimientos y el sistema de localización. Se tiene una infraestructura la cual se compone de 
\begin{itemize}
	\item red LAN
	\item servidor
	\item camaras
	\item suelo de goma
\end{itemize}
\subsubsection{Red LAN}
\begin{figure}[h]
	\includegraphics[width=1\textwidth]{CreacionInfraestructura/RedRobotario}
	\caption{Red LAN robotario }
	\label{fig:ConfiguracionRed}
\end{figure}
Se tiene una red LAN con topologia de red en estrella. En la Figura ~\ref{fig:ConfiguracionRed} se puede ver como estan configuradas las conexiones de la red  para el caso de 3 robots, donde los robots se conectan de forma inalámbrica y el servidor esta conectado mediante una conexión cableada, bien puede ser también inalámbrica.\\
La transmisión de la información se realiza a través del protocolo UDP, es un servicio no orientado a conexión y es justo lo que el robotario necesita, porque mantener una conexión usando el protocolo TCP con muchos robots involucrados y con conexiones inalambricas que se enfrentan al problema de las interferencias, provocaria retrasos en la transmisión de información y por lo tanto el robotario no funcionaría correctamente.\\
La información que se envia mediante la red LAN tiene una estructura definida para que los robots o el servidor puedan identificar los paquetes que vienen y el tipo de paque que llega.\\
Los paquetes tienen una cabecera:
\begin{itemize}
	\item \textbf{id} identificador del origen
	\item \textbf{op}. Código de operación, está en hexadecimal.
	\item \textbf{len}. Longitud de los datos que se envían.
\end{itemize}

Y los datos se envian en un array de tipo unsigned char. la longitud total es de 255 bytes, definida para los robots y el servidor. Se envia la longitud de los datos para hacer una detección de errores en los paquetes recibidos, si el receptor recibe un paquete de una longitud distinta a la enviada por len, o en caso de ser cero la longitud de los datos, si el tamaño del paquete recibido es diferente al tamaño de las cabeceras, el paquete se desecha, no se pide otro pues esto produce retrasos. Se hace una detección de errores, debido a que si al robot le llega un paquete corrupto, el robot se bloquea o deja de funcionar correctamente pues trata al paquete corrupto como una instrucción. Los robots y el servidor comparten el mismo codigo para la estructura de los paquetes se muestra a continuación en conjunto a los codigos de las operaciones.

 \begin{lstlisting}
const int MAXDATASIZE =255; //numero de bytes que se pueden recibir
const int HEADER_LEN = sizeof(unsigned short)*3;
struct appdata{
	
	unsigned short id; //identificador
	unsigned short op; //codigo de operacion
	unsigned short len; /* longitud de datos */
	unsigned char data [MAXDATASIZE-HEADER_LEN];//datos

	
	
};
//operacion error
#define OP_ERROR            0xFFFF
//operaciones requeridas por central
#define OP_SALUDO           0x0001
#define OP_MOVE_WHEEL       0x0002//da orden para mover ruedas wd,wi
#define OP_STOP_WHEEL       0x0003//para las ruedas wd,wi
#define OP_VEL_ROBOT        0X0005//devuelve la velocidad de las ruedas en rad/s wd,wi
#define OP_IMU              0x0006//devuelve lectura de giroscopo y acelerometro
#define OP_STOP_SERIAL      0X0007//para la comuniacion serie del robot
#define OP_POSITION         0x0008//manda la posicion inicial de robot
//operaciones cliente
#define OP_MESSAGE_RECIVE   0x0004
//broadcast
#define OP_BROADCAST        0x9999//operacion de difusion

 \end{lstlisting}
 Se puede ver que se ha definido un struct con las cabeceras y el array de datos, se usa unsigned char debido a que se pueden copiar bytes de diferentes tipos al array con mayor facilidad, asi no hace falta hacer un cast entre tipos, lo que provocaria errores en los datos.
\subsubsection{Servidor}
Se tiene un servidor que tiene la función de localizar a los robots en el robotario, y dar instrucciones a los diferentes robots que dependerán del experimento que se haga. La localización de los robots se hace mediante unas camaras y una libreria de visión que se llama OpenCV. Para localizar a los robots, se les coloca un codigo QR que se denomina Marker, el cual tiene codificado un ID, en la Figura ~\ref{fig:markers} se puede ver un ejemplo de como es un marker.\\
\begin{figure}
		\centering
	\includegraphics[width=0.45\textwidth]{CreacionInfraestructura/board}
	\caption{Ejemplo de marker}
	\label{fig:markers}
\end{figure}
Para poder usar correctamente la libreria, primero se deben calibrar las camaras, esto se hace imprimiendo a papel o usando en una tablet una tabla con diferentes marker como los de la Figura ~\ref{fig:markers}, se debe medir los lados y la separación entre marker consecutivos,con está información la librearia proporciona un programa que te estima los parámetros de las camaras, estos son coeficientes de distorsión en x,y,z, también te estima la longitud focal y los centros óticos. Con estos parámetros se puede estimar la posición de los diferentes markers en coordenadas x,y,z. Esta estimación se usa para la navegación de los robots.